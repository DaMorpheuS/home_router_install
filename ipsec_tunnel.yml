---
- name: Configure IPsec VPN tunnels using StrongSwan (swanctl)
  hosts: routers
  become: yes
  
  vars:
    # Local configuration
    local_subnet: "{{ ipsec_local_subnet | default('192.168.2.0/24') }}"
    local_public_ip: "{{ ipsec_local_public_ip | default('%any') }}"  # Use %any for dynamic IP
    
    # Remote peer configuration
    remote_peer_ip: "{{ ipsec_remote_peer_ip | default('213.124.134.50') }}"
    
    # Tunnel 1: koopmans
    tunnel1_name: "{{ ipsec_tunnel1_name | default('koopmans') }}"
    tunnel1_remote_subnet: "{{ ipsec_tunnel1_remote_subnet | default('192.168.100.0/24') }}"
    
    # Tunnel 2: doubleme
    tunnel2_name: "{{ ipsec_tunnel2_name | default('doubleme') }}"
    tunnel2_remote_subnet: "{{ ipsec_tunnel2_remote_subnet | default('192.168.20.0/24') }}"
    
    # Authentication
    psk_secret: "{{ ipsec_psk_secret | default('K00pm@ns2024') }}"
    
    # Encryption parameters
    ike_proposals: "{{ ipsec_ike_proposals | default('aes256-sha1-modp1536') }}"
    esp_proposals: "{{ ipsec_esp_proposals | default('aes256-sha1-modp1536') }}"
    ike_lifetime: "{{ ipsec_ike_lifetime | default('28800s') }}"
    
    # DPD settings
    dpd_delay: "{{ ipsec_dpd_delay | default('30s') }}"
    dpd_timeout: "{{ ipsec_dpd_timeout | default('120s') }}"
    
  tasks:
    - name: Gather distribution facts
      ansible.builtin.setup:
        gather_subset:
          - distribution
      tags: always
      
    - name: Check if StrongSwan packages are installed
      ansible.builtin.command: dpkg -l strongswan strongswan-swanctl strongswan-charon strongswan-pki libcharon-extra-plugins
      register: strongswan_packages_check
      changed_when: false
      failed_when: strongswan_packages_check.rc != 0
      tags: packages
      
    - name: Ensure swanctl configuration directory exists
      ansible.builtin.file:
        path: /etc/swanctl
        state: directory
        mode: '0755'
      tags: configure
      
    - name: Ensure swanctl subdirectories exist
      ansible.builtin.file:
        path: "/etc/swanctl/{{ item }}"
        state: directory
        mode: '0750'
      loop:
        - conf.d
        - x509
        - x509ca
        - x509crl
        - pubkey
        - private
        - rsa
        - ecdsa
        - pkcs8
        - pkcs12
      tags: configure
      
    - name: Backup existing swanctl configuration
      ansible.builtin.copy:
        src: /etc/swanctl/swanctl.conf
        dest: /etc/swanctl/swanctl.conf.backup.{{ ansible_date_time.epoch }}
        remote_src: yes
        mode: '0644'
      tags: backup
      ignore_errors: yes
      
    - name: Create swanctl.conf with IPsec tunnel configuration
      ansible.builtin.copy:
        dest: /etc/swanctl/swanctl.conf
        mode: '0644'
        content: |
          # StrongSwan swanctl configuration
          # Generated by Ansible
          # Modern configuration format for StrongSwan
          
          connections {
              
              # IPsec connection to {{ remote_peer_ip }}
              # Both tunnels ({{ tunnel1_name }} and {{ tunnel2_name }}) share this connection
              {{ tunnel1_name }} {
                  version = 1
                  local_addrs  = %any
                  remote_addrs = {{ remote_peer_ip }}
                  
                  local {
                      auth = psk
                      id = %any
                  }
                  remote {
                      auth = psk
                      id = {{ remote_peer_ip }}
                  }
                  
                  dpd_delay   = {{ dpd_delay }}
                  dpd_timeout = {{ dpd_timeout }}
                  
                  proposals   = {{ ike_proposals }}
                  rekey_time  = {{ ike_lifetime }}
                  
                  children {
                      # Child tunnel 1: {{ tunnel1_name }}
                      {{ tunnel1_name }}-child {
                          local_ts  = {{ local_subnet }}
                          remote_ts = {{ tunnel1_remote_subnet }}
                          esp_proposals = {{ esp_proposals }}
                          mode = tunnel
                          start_action = start
                      }
                      # Child tunnel 2: {{ tunnel2_name }}
                      {{ tunnel2_name }}-child {
                          local_ts  = {{ local_subnet }}
                          remote_ts = {{ tunnel2_remote_subnet }}
                          esp_proposals = {{ esp_proposals }}
                          mode = tunnel
                          start_action = start
                      }
                  }
              }
              
          }
          
          secrets {
              # Pre-shared key authentication
              ike-psk {
                  id = %any
                  secret = "{{ psk_secret }}"
              }
          }
      tags: configure
      notify: reload swanctl
      
    - name: Check available StrongSwan services
      ansible.builtin.shell: systemctl list-unit-files | grep -E 'strongswan|charon' | awk '{print $1}'
      register: strongswan_services
      changed_when: false
      tags: service
      
    - name: Display available StrongSwan services
      ansible.builtin.debug:
        var: strongswan_services.stdout_lines
      tags: service
      
    - name: Enable strongswan-starter service
      ansible.builtin.systemd:
        name: strongswan-starter
        enabled: yes
      tags: service
      ignore_errors: yes
      
    - name: Start strongswan-starter service
      ansible.builtin.systemd:
        name: strongswan-starter
        state: started
      tags: service
      register: starter_service
      ignore_errors: yes
      
    - name: Wait for strongswan-starter to initialize
      ansible.builtin.pause:
        seconds: 2
      tags: service
      when: starter_service is changed
      
    - name: Disable old ipsec service (if exists and different from starter)
      ansible.builtin.systemd:
        name: ipsec
        enabled: no
        state: stopped
      tags: service
      ignore_errors: yes
      when: false  # Keep for reference but don't run
      
    - name: Enable strongswan-swanctl service
      ansible.builtin.systemd:
        name: strongswan-swanctl
        enabled: yes
      tags: service
      when: "'strongswan-swanctl.service' in strongswan_services.stdout"
      
    - name: Start strongswan-swanctl service
      ansible.builtin.systemd:
        name: strongswan-swanctl
        state: started
      tags: service
      register: swanctl_start
      when: "'strongswan-swanctl.service' in strongswan_services.stdout"
      
    - name: Enable and start charon-systemd (alternative)
      ansible.builtin.systemd:
        name: charon-systemd
        enabled: yes
        state: started
      tags: service
      register: charon_start
      when: "'strongswan-swanctl.service' not in strongswan_services.stdout and 'charon-systemd.service' in strongswan_services.stdout"
      ignore_errors: yes
      
    - name: Wait a moment for service to initialize
      ansible.builtin.pause:
        seconds: 3
      tags: service
      
    - name: Check if VICI socket exists
      ansible.builtin.stat:
        path: /var/run/charon.vici
      register: vici_socket
      tags: service
      
    - name: Display VICI socket status
      ansible.builtin.debug:
        msg: "VICI socket exists: {{ vici_socket.stat.exists | default(false) }}"
      tags: service
      
    - name: Check charon service status
      ansible.builtin.command: systemctl status strongswan-swanctl
      register: charon_status
      changed_when: false
      ignore_errors: yes
      tags: service
      when: "'strongswan-swanctl.service' in strongswan_services.stdout"
      
    - name: Display charon service status
      ansible.builtin.debug:
        var: charon_status.stdout_lines
      tags: service
      when: charon_status is defined
      
    - name: Check charon logs if service failed
      ansible.builtin.command: journalctl -u strongswan-swanctl -n 30 --no-pager
      register: charon_logs
      changed_when: false
      when: not vici_socket.stat.exists | default(false)
      tags: service
      
    - name: Display charon logs
      ansible.builtin.debug:
        var: charon_logs.stdout_lines
      when: charon_logs is defined
      tags: service
      
    - name: Try alternative - start charon daemon manually
      ansible.builtin.command: charon &
      when: not vici_socket.stat.exists | default(false)
      async: 10
      poll: 0
      ignore_errors: yes
      tags: service
      
    - name: Wait for VICI socket to be available (if needed)
      ansible.builtin.wait_for:
        path: /var/run/charon.vici
        timeout: 30
      tags: service
      when: not vici_socket.stat.exists | default(false)
      ignore_errors: yes
      
    - name: Create swanctl auto-load script
      ansible.builtin.copy:
        dest: /usr/local/bin/swanctl-autoload.sh
        mode: '0755'
        content: |
          #!/bin/bash
          # Wait for VICI socket to be available before loading swanctl config
          
          VICI_SOCKET="/var/run/charon.vici"
          MAX_WAIT=30
          COUNTER=0
          
          echo "Waiting for VICI socket to be available..."
          
          while [ ! -S "$VICI_SOCKET" ] && [ $COUNTER -lt $MAX_WAIT ]; do
            sleep 1
            COUNTER=$((COUNTER + 1))
            echo "Waiting for socket... ($COUNTER/$MAX_WAIT)"
          done
          
          if [ ! -S "$VICI_SOCKET" ]; then
            echo "ERROR: VICI socket not available after ${MAX_WAIT}s"
            exit 1
          fi
          
          echo "VICI socket found, loading swanctl configuration..."
          /usr/sbin/swanctl --load-all
          
          exit $?
      tags: configure
      
    - name: Create systemd service to auto-load swanctl on boot
      ansible.builtin.copy:
        dest: /etc/systemd/system/swanctl-autoload.service
        mode: '0644'
        content: |
          [Unit]
          Description=Load swanctl IPsec configuration
          After=strongswan-swanctl.service network-online.target
          Wants=network-online.target
          PartOf=strongswan-swanctl.service
          
          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/swanctl-autoload.sh
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
      tags: configure
      notify: reload systemd
      
    - name: Enable swanctl-autoload service
      ansible.builtin.systemd:
        name: swanctl-autoload
        enabled: yes
        daemon_reload: yes
      tags: configure
      
    - name: Load swanctl configuration
      ansible.builtin.command: swanctl --load-all
      register: swanctl_load
      changed_when: swanctl_load.rc == 0
      failed_when: false
      tags: configure
      
    - name: Display swanctl load result
      ansible.builtin.debug:
        msg: |
          Return code: {{ swanctl_load.rc }}
          Output: {{ swanctl_load.stdout }}
          {% if swanctl_load.rc != 0 %}
          Error: {{ swanctl_load.stderr }}
          {% endif %}
      tags: configure
      
    - name: Check if configuration was loaded despite errors
      ansible.builtin.command: swanctl --list-conns
      register: loaded_conns
      changed_when: false
      ignore_errors: yes
      tags: configure
      
    - name: Display loaded connections check
      ansible.builtin.debug:
        msg: |
          Connections check:
          {{ loaded_conns.stdout }}
      tags: configure
      
    - name: Verify swanctl load was successful
      ansible.builtin.fail:
        msg: |
          Failed to load swanctl configuration properly.
          Return code: {{ swanctl_load.rc }}
          
          Troubleshooting steps:
          1. Check service: systemctl status strongswan-swanctl
          2. Check logs: journalctl -u strongswan-swanctl -n 50
          3. Check socket: ls -l /var/run/charon.vici
          4. Manual start: sudo systemctl restart strongswan-swanctl
          5. Test load: sudo swanctl --load-all
      when: swanctl_load.rc != 0 and (loaded_conns.rc != 0 or tunnel1_name not in loaded_conns.stdout)
      tags: configure
      
    - name: Add IPsec firewall rules to nftables
      ansible.builtin.blockinfile:
        path: /etc/nftables.conf
        marker: "# {mark} ANSIBLE MANAGED IPSEC RULES"
        insertafter: "chain input {"
        block: |2
                  
                  # === IPsec VPN - Allow IKE and ESP ===
                  # Allow IKE (UDP 500)
                  udp dport 500 accept
                  
                  # Allow IKE NAT-T (UDP 4500)
                  udp dport 4500 accept
                  
                  # Allow ESP protocol
                  ip protocol esp accept
      tags: firewall
      notify: reload nftables
      
    - name: Reload nftables to apply IPsec rules
      ansible.builtin.systemd:
        name: nftables
        state: reloaded
      tags: firewall
      
    - name: Wait a moment for tunnels to establish
      ansible.builtin.pause:
        seconds: 5
      tags: validate
      
    - name: Check IPsec tunnel status
      ansible.builtin.command: swanctl --list-sas
      register: ipsec_status
      changed_when: false
      tags: validate
      
    - name: Display IPsec tunnel status
      ansible.builtin.debug:
        var: ipsec_status.stdout_lines
      tags: validate
      
    - name: Check loaded connections
      ansible.builtin.command: swanctl --list-conns
      register: ipsec_conns
      changed_when: false
      tags: validate
      
    - name: Display loaded connections
      ansible.builtin.debug:
        var: ipsec_conns.stdout_lines
      tags: validate
      
    - name: Create IPsec status script
      ansible.builtin.copy:
        dest: /usr/local/bin/ipsec-status
        mode: '0755'
        content: |
          #!/bin/bash
          # IPsec Tunnel Status Script
          
          echo "=== StrongSwan IPsec Tunnel Status ==="
          echo ""
          echo "Active Security Associations (SAs):"
          swanctl --list-sas
          echo ""
          echo "Loaded Connections:"
          swanctl --list-conns
          echo ""
          echo "Service Status:"
          systemctl status strongswan-swanctl --no-pager -l 2>/dev/null || systemctl status charon-systemd --no-pager -l
      tags: tools
      
    - name: Display IPsec management information
      ansible.builtin.debug:
        msg: |
          IPsec VPN Tunnels Configured!
          
          Configuration file: /etc/swanctl/swanctl.conf
          Auto-load service:  swanctl-autoload.service (enabled on boot)
          
          Tunnels:
          1. {{ tunnel1_name }}: {{ local_subnet }} <-> {{ tunnel1_remote_subnet }} via {{ remote_peer_ip }}
          2. {{ tunnel2_name }}: {{ local_subnet }} <-> {{ tunnel2_remote_subnet }} via {{ remote_peer_ip }}
          
          Management Commands:
          - View tunnel status:      swanctl --list-sas (or: ipsec-status)
          - View connections:        swanctl --list-conns
          - Reload configuration:    swanctl --load-all (or: systemctl restart swanctl-autoload)
          - Initiate tunnel:         swanctl --initiate --child {{ tunnel1_name }}-child
          - Terminate tunnel:        swanctl --terminate --ike {{ tunnel1_name }}
          - View logs:               journalctl -u strongswan-swanctl -f
          - Service status:          systemctl status strongswan-swanctl
          - Auto-load status:        systemctl status swanctl-autoload
          
          Testing:
          - Ping remote network 1:   ping -c 3 {{ tunnel1_remote_subnet | regex_replace('/.*', '') | regex_replace('\\.0$', '.1') }}
          - Ping remote network 2:   ping -c 3 {{ tunnel2_remote_subnet | regex_replace('/.*', '') | regex_replace('\\.0$', '.1') }}
          
          Firewall Rules Added:
          - UDP 500 (IKE)
          - UDP 4500 (IKE NAT-T)
          - ESP protocol (IP protocol 50)
      tags: documentation
      
  handlers:
    - name: reload swanctl
      ansible.builtin.command: swanctl --load-all
      
    - name: reload nftables
      ansible.builtin.command: nft -f /etc/nftables.conf
      
    - name: reload systemd
      ansible.builtin.systemd:
        daemon_reload: yes


